package main

import (
	"encoding/json"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"
)

// landConfig holds configuration for the land operation
type landConfig struct {
	timeout       time.Duration
	pollInterval  time.Duration
	deleteBranch  bool
	requireChecks bool
	autoMode      bool
	dryRun        bool
}

// checkStatus represents the status of a CI check
type checkStatus struct {
	Name        string `json:"name"`
	State       string `json:"state"`
	Bucket      string `json:"bucket"`
	Workflow    string `json:"workflow"`
	Description string `json:"description"`
}

// prInfo holds information about a PR for landing
type prInfo struct {
	Number      int
	Title       string
	HeadSHA     string
	BaseBranch  string
	Commit      *Commit
}

// landStack orchestrates the landing of a stack of PRs
func landStack(cfg landConfig) error {
	// ensure clean working directory
	if !validateGitStatusClean() {
		return fmt.Errorf("working directory has uncommitted changes")
	}

	// get current stack
	originMain := fmt.Sprintf("%v/%v", config.git.remote, config.git.remoteTrunk)
	debugf("getting stacked commits from %s to %s", originMain, head)
	stackedCommits := must(getStackedCommits(originMain, head))
	
	if len(stackedCommits) == 0 {
		fmt.Println("no commits to land")
		return nil
	}
	
	debugf("found %d commits to land", len(stackedCommits))

	// build PR info for each commit
	prs := []prInfo{}
	for _, commit := range stackedCommits {
		if commit.PRNumber == 0 {
			// try to find PR number
			debugf("searching for PR for commit %s", commit.ShortHash())
			commit.PRNumber = must(githubSearchPRNumberForCommit(commit))
			if commit.PRNumber == 0 {
				return fmt.Errorf("no PR found for commit %s", commit.ShortHash())
			}
		}
		
		debugf("found PR #%d for commit %s: %s", commit.PRNumber, commit.ShortHash(), commit.Title)
		
		// get PR details
		_ = must(githubGetPRByNumber(commit.PRNumber))
		prs = append(prs, prInfo{
			Number:     commit.PRNumber,
			Title:      commit.Title,
			HeadSHA:    commit.Hash,
			BaseBranch: config.git.remoteTrunk,
			Commit:     commit,
		})
	}

	// land PRs from bottom to top (reverse order)
	for i := 0; i < len(prs); i++ {
		pr := prs[i]
		fmt.Printf("\n[%d/%d] Landing PR #%d: %s\n", i+1, len(prs), pr.Number, pr.Title)
		
		if cfg.dryRun {
			fmt.Printf("  [DRY-RUN] Would merge PR #%d\n", pr.Number)
			continue
		}

		// wait for checks if required
		if cfg.requireChecks {
			fmt.Printf("  ⠼ Waiting for checks...\n")
			if err := waitForChecks(pr.Number, cfg); err != nil {
				return fmt.Errorf("checks failed for PR #%d: %w", pr.Number, err)
			}
			fmt.Printf("  ✓ All checks passed\n")
		} else {
			debugf("skipping CI checks (requireChecks=false)")
		}

		// detect auto-generated commits
		debugf("checking for auto-generated commits on PR #%d", pr.Number)
		currentHeadSHA, hasAutoCommits := detectAutoGeneratedCommits(pr.Number)
		if hasAutoCommits {
			fmt.Printf("  ⚠ CI added commits, head SHA changed: %s -> %s\n", pr.HeadSHA[:8], currentHeadSHA[:8])
			pr.HeadSHA = currentHeadSHA
		} else {
			debugf("no auto-generated commits detected")
		}

		// update next PR's base BEFORE merging to avoid it being closed
		if i < len(prs)-1 && !cfg.dryRun {
			nextPR := prs[i+1]
			fmt.Printf("  ⠼ Updating next PR #%d base to %s...\n", nextPR.Number, config.git.remoteTrunk)
			if err := updatePRBase(nextPR.Number, config.git.remoteTrunk); err != nil {
				// not fatal, GitHub might handle it automatically
				fmt.Printf("  ⚠ Could not update PR #%d base: %v\n", nextPR.Number, err)
			} else {
				fmt.Printf("  ✓ Updated PR #%d base\n", nextPR.Number)
			}
		}
		
		// merge the PR
		if cfg.dryRun {
			fmt.Printf("  [DRY-RUN] Would merge PR\n")
		} else {
			fmt.Printf("  ⠼ Merging PR...\n")
			if err := mergePR(pr.Number, pr.Title, pr.HeadSHA, cfg); err != nil {
				return fmt.Errorf("failed to merge PR #%d: %w", pr.Number, err)
			}
			fmt.Printf("  ✓ Merged to %s\n", config.git.remoteTrunk)
		}

		// pull latest main
		if !cfg.dryRun {
			fmt.Printf("  ⠼ Pulling latest %s...\n", config.git.remoteTrunk)
			must(git("fetch", config.git.remote, config.git.remoteTrunk))
			must(git("checkout", config.git.remoteTrunk))
			must(git("pull", config.git.remote, config.git.remoteTrunk))
		}
		
		if !cfg.dryRun {
			fmt.Printf("  ✓ PR #%d successfully landed\n", pr.Number)
		}
	}

	if cfg.dryRun {
		fmt.Printf("\n[DRY-RUN] Would land %d PRs\n", len(prs))
	} else {
		fmt.Printf("\n✓ Successfully landed %d PRs\n", len(prs))
	}
	return nil
}

// waitForChecks waits for required CI checks to pass
func waitForChecks(prNumber int, cfg landConfig) error {
	startTime := time.Now()
	debugf("waiting for required checks on PR #%d (timeout: %v)", prNumber, cfg.timeout)
	
	for {
		// check if timeout exceeded
		if time.Since(startTime) > cfg.timeout {
			return fmt.Errorf("timeout waiting for checks after %v", cfg.timeout)
		}

		// get check status
		debugf("polling check status for PR #%d", prNumber)
		output, err := gh("pr", "checks", strconv.Itoa(prNumber), "--required", "--json", "name,state,bucket")
		if err != nil {
			// no required checks configured, which is fine
			debugf("no required checks configured for PR #%d", prNumber)
			return nil
		}
		
		var checks []checkStatus
		if err := json.Unmarshal([]byte(output), &checks); err != nil {
			return fmt.Errorf("failed to parse check status: %w", err)
		}

		// check if all required checks passed
		allPassed := true
		failedChecks := []string{}
		pendingChecks := []string{}
		
		for _, check := range checks {
			switch check.Bucket {
			case "pass", "skipping":
				// these are OK
			case "fail", "cancel":
				failedChecks = append(failedChecks, check.Name)
				allPassed = false
			case "pending":
				pendingChecks = append(pendingChecks, check.Name)
				allPassed = false
			}
		}

		if len(failedChecks) > 0 {
			return fmt.Errorf("required checks failed: %s", strings.Join(failedChecks, ", "))
		}

		if allPassed {
			debugf("all required checks passed for PR #%d", prNumber)
			return nil
		}

		// show pending checks
		fmt.Printf("    Pending checks (%d): %s\n", len(pendingChecks), strings.Join(pendingChecks, ", "))
		debugf("waiting %v before next poll", cfg.pollInterval)
		
		// wait before next poll
		time.Sleep(cfg.pollInterval)
	}
}

// detectAutoGeneratedCommits checks if CI has added commits to the PR
func detectAutoGeneratedCommits(prNumber int) (string, bool) {
	// get current PR head SHA
	debugf("getting current head SHA for PR #%d", prNumber)
	output := must(gh("pr", "view", strconv.Itoa(prNumber), "--json", "headRefOid"))
	
	var prData struct {
		HeadRefOid string `json:"headRefOid"`
	}
	json.Unmarshal([]byte(output), &prData)
	
	debugf("current head SHA for PR #%d: %s", prNumber, prData.HeadRefOid[:8])
	
	// for now, just return the current SHA
	// TODO: compare with our tracked commit to detect auto-generated commits
	return prData.HeadRefOid, false
}

// mergePR merges a pull request
func mergePR(prNumber int, title, headSHA string, cfg landConfig) error {
	// get PR details to clean up the squash commit message
	debugf("getting PR #%d details for merge", prNumber)
	pr := must(githubGetPRByNumber(prNumber))
	
	// clean up the PR body for the squash commit
	body := cleanupPRBodyForMerge(pr.Body)
	debugf("cleaned PR body (removed footer/template): %d -> %d chars", len(pr.Body), len(body))
	
	args := []string{"pr", "merge", strconv.Itoa(prNumber)}
	
	// use squash merge
	args = append(args, "--squash")
	
	// set custom title and body for the squash commit
	// gh pr merge uses --subject for title and --body for body
	args = append(args, "--subject", title)
	if body != "" {
		args = append(args, "--body", body)
	} else {
		// provide empty body to override PR description
		args = append(args, "--body", "")
	}
	
	// match head commit to prevent race conditions
	if headSHA != "" {
		args = append(args, "--match-head-commit", headSHA)
	}
	
	// delete branch if configured
	if cfg.deleteBranch {
		args = append(args, "--delete-branch")
	}
	
	// use auto mode if configured
	if cfg.autoMode {
		args = append(args, "--auto")
	}
	
	debugf("executing: gh %s", strings.Join(args, " "))
	_, err := gh(args...)
	return err
}

// cleanupPRBodyForMerge removes the stack info footer and empty template from PR body
func cleanupPRBodyForMerge(body string) string {
	if body == "" {
		return ""
	}
	
	// normalize line endings
	body = strings.ReplaceAll(body, "\r\n", "\n")
	
	// remove stack info footer (everything after "---")
	parts := strings.Split(body, "\n---\n")
	if len(parts) > 0 {
		body = parts[0]
	}
	
	// check if it's the empty template using regexp
	// matches template with "# Summary" and multiple newlines/spaces and optional <br> tags
	emptyTemplateRegex := regexp.MustCompile(`(?s)^#\s*Summary\s*(\n|\s|<br\/?>)*$`)
	
	if emptyTemplateRegex.MatchString(strings.TrimSpace(body)) {
		return ""
	}
	
	return strings.TrimSpace(body)
}

// updatePRBase updates the base branch of a PR
func updatePRBase(prNumber int, newBase string) error {
	_, err := gh("pr", "edit", strconv.Itoa(prNumber), "--base", newBase)
	return err
}

